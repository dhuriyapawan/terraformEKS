name: CI CD Pipeline

on:
  pull_request:
    types: [closed]
    branches: [dev]
    paths-ignore:
      - VERSION

  push:
    branches:
      - dev
      - prod
      - staging
    paths-ignore:
      - VERSION
      - README.md

permissions:
  contents: write

jobs:
  build:
    runs-on: ubuntu-latest

    outputs:
      releaseTrue: ${{ steps.release-status.outputs.rel-status }}
      currentVersion: ${{ steps.get-version.outputs.version }}
      currentENV: ${{ steps.current-env.outputs.ENV }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Node
        uses: actions/setup-node@v3
        with:
          node-version: 18

      - name: Install dependencies
        run: |
          cd app
          npm install

      - name: Run tests
        run: |
          cd app
          npm test

      - name: Determine version increment
        id: version-increment
        run: |
          commit_message=$(git log -1 --pretty=%B)

          if [[ "$commit_message" == *"major:"* ]]; then
            echo "increment=major" >> "$GITHUB_OUTPUT"
            echo "release=true" >> "$GITHUB_OUTPUT"
          elif [[ "$commit_message" == *"minor:"* ]]; then
            echo "increment=minor" >> "$GITHUB_OUTPUT"
            echo "release=true" >> "$GITHUB_OUTPUT"
          elif [[ "$commit_message" == *"patch:"* ]]; then
            echo "increment=patch" >> "$GITHUB_OUTPUT"
            echo "release=true" >> "$GITHUB_OUTPUT"
          else
            echo "release=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Publish release status
        id: release-status
        run: |
          echo "rel-status=${{ steps.version-increment.outputs.release }}" >> "$GITHUB_OUTPUT"

      - name: Publish current environment
        id: current-env
        run: |
          ENVIRONMENT="${GITHUB_REF#refs/heads/}"
          echo "ENV=${ENVIRONMENT}" >> "$GITHUB_OUTPUT"

      - name: Get current version
        id: get-version
        run: echo "version=$(cat VERSION)" >> "$GITHUB_OUTPUT"

      - name: Increment version
        id: increment-version
        if: github.ref == 'refs/heads/dev' && steps.version-increment.outputs.release == 'true'
        run: |
          echo "new_version=$(docker run --rm -v ${PWD}:/app treeder/bump ${{ steps.version-increment.outputs.increment }})" >> "$GITHUB_OUTPUT"

      - name: Update VERSION file
        if: github.ref == 'refs/heads/dev' && steps.version-increment.outputs.release == 'true'
        run: echo "${{ steps.increment-version.outputs.new_version }}" > VERSION

      - name: Get updated version
        id: updated-version
        run: echo "version=$(cat VERSION)" >> "$GITHUB_OUTPUT"

      - name: Commit VERSION file
        if: github.ref == 'refs/heads/dev' && steps.version-increment.outputs.release == 'true'
        uses: EndBug/add-and-commit@v9
        with:
          add: VERSION
          author_name: Afraz Ahmed
          author_email: aphraz@live.com
          message: Updating VERSION file
          push: origin dev --force
          tag: ${{ steps.updated-version.outputs.version }}
          tag_push: --force

      - name: Login to DockerHub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_ACCESS_TOKEN }}

      - name: Docker build & push (dev)
        if: github.ref == 'refs/heads/dev'
        run: |
          cd app
          docker build -t ${{ secrets.DOCKERHUB_USERNAME }}/frontend:${{ steps.updated-version.outputs.version }}-dev .
          docker push ${{ secrets.DOCKERHUB_USERNAME }}/frontend:${{ steps.updated-version.outputs.version }}-dev

      - name: Docker build & push (prod)
        if: github.ref == 'refs/heads/prod'
        run: |
          cd app
          docker build -t ${{ secrets.DOCKERHUB_USERNAME }}/frontend:${{ steps.updated-version.outputs.version }}-prod .
          docker push ${{ secrets.DOCKERHUB_USERNAME }}/frontend:${{ steps.updated-version.outputs.version }}-prod

      - name: Docker build & push (staging)
        if: github.ref == 'refs/heads/staging'
        run: |
          cd app
          docker build -t ${{ secrets.DOCKERHUB_USERNAME }}/frontend:${{ steps.updated-version.outputs.version }}-staging .
          docker push ${{ secrets.DOCKERHUB_USERNAME }}/frontend:${{ steps.updated-version.outputs.version }}-staging

  deployment:
    needs: build
    runs-on: ubuntu-latest

    env:
      TF_IN_AUTOMATION: "1"
      S3_BUCKET: ${{ secrets.S3_BUCKET }}
      S3_REGION: ${{ secrets.S3_REGION }}
      DYNAMODB_TABLE: ${{ secrets.DYNAMODB_TABLE }}
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_REGION: ${{ secrets.AWS_REGION }}
      ENVIRONMENT: ${{ needs.build.outputs.currentENV }}
      TF_VAR_environment: ${{ needs.build.outputs.currentENV }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2

      - name: Install AWS CLI
        run: |
          curl https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip -o awscliv2.zip
          unzip awscliv2.zip
          sudo ./aws/install --update

      - name: Terraform Init
        run: |
          cd terraform
          terraform init \
            -backend-config="bucket=${S3_BUCKET}" \
            -backend-config="key=state/${ENVIRONMENT}.tfstate" \
            -backend-config="region=${S3_REGION}" \
            -backend-config="dynamodb_table=${DYNAMODB_TABLE}"

      - name: Install kubectl
        uses: azure/setup-kubectl@v3

      - name: Configure kubectl
        run: |
          aws eks update-kubeconfig \
            --region ${AWS_REGION} \
            --name e2ecicd-eks-${ENVIRONMENT}

      - name: Terraform Apply
        run: |
          cd terraform
          terraform apply -auto-approve

      - name: Create namespace
        run: |
          kubectl get ns app-${ENVIRONMENT} || kubectl create ns app-${ENVIRONMENT}

      - name: Deploy with kustomize
        run: |
          kubectl apply -k kustomize/overlays/${ENVIRONMENT}
